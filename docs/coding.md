# コーディングルール

## 1. 配列・オブジェクトのイミュータビリティ方針

### 1-1. 外部 API ではイミュータブルに扱う

**規約**

- 公開関数・メソッド(他モジュールから呼ばれる API)は、
  - 引数として受け取った配列・オブジェクトを **直接変更しない** こと
  - 状態の変更が必要な場合は、**新しいオブジェクト/配列を生成して返す** こと

**理由**

- 呼び出し元から見たときに、副作用の有無が分かりやすくなる
- 意図しない共有データの破壊(別名参照のバグ)を防ぎやすい
- テストしやすくなり、関数ごとの責務が明確になる

**例**

```typescript
// NG: 引数の配列を直接書き換えている
export function addItemNg(list: string[], item: string): string[] {
  list.push(item);
  return list;
}

// OK: 新しい配列を返す
export function addItemOk(list: readonly string[], item: string): string[] {
  return [...list, item];
}
```

### 1-2. 内部実装では性能のためのミュータブル操作を許容する

**規約**

- モジュール内で完結する内部実装(外部から直接呼ばれない関数)では、
  - パフォーマンスが重要な箇所に限り、`let` や `push` などのミュータブル操作を **許容** する
- ただし、そのミュータブルな値がそのまま外部に晒されないように注意すること

**理由**

- `const` + `[...a, ...b]` などによる完全イミュータブルな実装は、
  - 大きな配列や高頻度な呼び出しに対して、**メモリと CPU のコストが高くなる**
- ライブラリやコア処理では、性能がそのまま利用者全体の体験に影響するため、
  - 外部 API はイミュータブルに保ちつつ、
  - 内部では必要な範囲でミュータブルに実装するのが実務的なバランスである

**例**

```typescript
// 外部 API(イミュータブルに見える)
export function unique<T>(items: readonly T[]): T[] {
  const copy = [...items]; // 外部からの配列をコピー
  inPlaceUnique(copy); // 内部で破壊的に変更
  return copy; // 破壊されたのはこの関数内で作った配列のみ
}

// 内部実装(ミュータブル許容)
function inPlaceUnique<T>(items: T[]): void {
  const seen = new Set<T>();
  let writeIndex = 0;
  for (let i = 0; i < items.length; i++) {
    const v = items[i];
    if (!seen.has(v)) {
      seen.add(v);
      items[writeIndex++] = v;
    }
  }
  items.length = writeIndex;
}
```

### 1-3. `[...a, ...b]` による配列再生成の使いどころ

**規約**

- `[...a, ...b]` などのスプレッドによる配列再生成は、
  - 「データサイズが小さい」「呼び出し頻度が低い」「可読性を優先したい」箇所で使用してよい
- 一方で、以下のような箇所では使用を控え、必要ならミュータブルなロジックに切り替えること
  - 大きな配列(おおよそ数万要素以上)が対象になり得る
  - 頻繁に呼ばれるホットパス
  - ネストしたループや再帰の中で何度も配列をコピーしている

**理由**

- スプレッドで配列を再生成すると、要素数 n に対して **O(n)** のコピーが発生する
- これをループやネスト内で繰り返すと、容易に **O(n^2)** 以上のコストになり、
  - メモリ使用量増加
  - GC 負荷増大
  - 実行時間の悪化
  を引き起こすため

**例(控えたいパターン)**

```typescript
// NG: ループ内で毎回コピーを作成
function badConcatAll<T>(lists: readonly T[][]): T[] {
  let result: T[] = [];
  for (const list of lists) {
    result = [...result, ...list];
  }
  return result;
}

// OK: push を使用してコピーを避ける
function goodConcatAll<T>(lists: readonly T[][]): T[] {
  const result: T[] = [];
  for (const list of lists) {
    result.push(...list);
  }
  return result;
}
```

## 2. ループと再帰の使用方針

### 2-1. 反復処理は原則 `for` / `while` / `for...of` で書く

**規約**

- 要素列・配列・木構造などの走査は、**原則として**
  `for` / `while` / `for...of` を用いた反復処理で実装すること
- 特に、入力サイズや深さに外部からの制約がないライブラリコードでは、
  再帰のみでループを実現することを原則禁止とする

**理由**

- JavaScript エンジンには末尾再帰最適化(TCO)の保証がなく、
  - 再帰のネストが深くなると、**スタックオーバーフロー (`RangeError`) のリスク** がある
- ライブラリコードは
  - 呼び出し側の入力サイズ・深さを制御できず、
  - 様々な環境(ブラウザ・Node.js)のスタック制限に依存するため、
    安全性の観点から再帰よりもループを優先する

**例**

```typescript
// OK: ループで実装した合計値計算
export function sum(nums: readonly number[]): number {
  let total = 0;
  for (const n of nums) {
    total += n;
  }
  return total;
}
```

### 2-2. 再帰を使ってよいケースとルール

**規約**

- 再帰を使用してよいのは、次の条件をすべて満たす場合とする
  - 再帰の深さに **理論的な上限があり**、それがスタック的に十分浅いと判断できること
  - その上限や前提を、コメント等でコード上にはっきり明示すること
  - ユニットテスト等で、その範囲内で正常に動作することを確認していること
- 上記条件を満たさない一般的な走査・探索処理は、
  - 再帰ではなくループ + 明示的スタック(配列)で実装すること

**理由**

- 再帰呼び出しは毎回コールスタックのフレームを積み増すため、
  - 深さが入力に比例して増える場合、入力次第で容易にスタックオーバーフローする
- 条件を満たす場合のみ、コードの分かりやすさを優先して再帰を許可することで、
  - 安全性と可読性のバランスを取る

**例(許容される再帰: 深さが限定された木構造)**

```typescript
// 深さが最大でも 10 程度に制限された UI ツリーを想定
// NOTE: この関数は UI ツリーの深さが 10 以下であることを前提とする。
//       それ以上の深さになるケースは設計上発生しない。
function renderTree(node: Node): void {
  renderNode(node);
  for (const child of node.children) {
    renderTree(child);
  }
}
```

## 3. このプロジェクトはライブラリである

### 3-1. アプリケーション開発の定番がアンチパターンになる理由

このプロジェクトはライブラリであり、アプリケーション開発とは異なる基準が求められます。

**アプリケーション開発では許容されるパターン:**

- `const` + スプレッド演算子による再生成(`[...a, x]`, `{...obj, foo: 1}`)
- 可読性を優先した再帰処理
- 「多少遅くても、読みやすさ・変更しやすさを優先」という判断

**ライブラリ開発ではアンチパターンになる理由:**

- **利用者の規模を制御できない**: ライブラリは誰がどのような規模で使うか分かりません。アプリケーション開発では「このデータは最大でも数百件」と分かっていても、ライブラリでは数万件で呼ばれる可能性があります
- **呼び出し頻度を制御できない**: アプリケーションでは「この処理は 1 回しか呼ばれない」と分かっていても、ライブラリではホットパスで何度も呼ばれる可能性があります
- **環境を制御できない**: ブラウザ・Node.js・エッジランタイムなど、様々な環境のスタック制限やメモリ制約に対応する必要があります
- **性能劣化が利用者全体に波及する**: ライブラリの非効率なコードは、それを使う全てのアプリケーションに影響します

### 3-2. ライブラリ開発の方針

**規約**

- 本ドキュメントの方針に従ってください
  - 「外部 API はイミュータブル」
  - 「内部は性能のためにミュータブルも許容」
  - 「反復処理はループ優先・再帰は限定的に使用」
- 性能クリティカルな箇所(大規模データや高頻度呼び出しが想定される処理)は、
  - コード中にその旨コメントを残してください
  - 必要に応じてベンチマークやプロファイル結果を添付してください

**理由**

- ライブラリは利用者・用途を制限できないため、スケールしたときの安全性・性能を優先する必要があります
- 理由をコメントで残しておくことで、後から読む人が「なぜミュータブルで書いているのか」を理解しやすくなり、不用意な「きれい化リファクタリング」による性能劣化を防げます
